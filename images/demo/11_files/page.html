<!DOCTYPE html>
<!-- saved from url=(0225)https://www.facebook.com/plugins/page.php?href=https%3A%2F%2Fwww.facebook.com%2FJbtdrc-287642701902801&tabs=timeline&width=300&height=500&small_header=false&adapt_container_width=true&hide_cover=false&show_facepile=true&appId -->
<html lang="en" id="facebook" class="svg no_js"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="referrer" content="origin-when-crossorigin" id="meta_referrer"><script nonce="">__DEV__=0;</script><title>Facebook</title><link type="text/css" rel="stylesheet" href="./oYRRf1tquzt.css" data-bootloader-hash="UEMx96n" crossorigin="anonymous">
<script nonce="">window.onloadRegister_DEPRECATED=function(){},window.onafterloadRegister_DEPRECATED=function(){},window.ServerJSQueue={add:function(){}};</script><script>/*
 * This entire block is wrapped in an IIFE to prevent polluting the scope of the web page with
 * functions created by this extension.
 */
(function(realOpen, realSend, realFetch) {
    /*
     * Sometimes pages overwrite standard objects with global
     * variables. Where possible, we extract fresh versions from an
     * iframe.
     */
    const iframe = document.createElement('iframe');
    document.documentElement.appendChild(iframe);

    // Initialise with global values
    let URL = window.URL;
    let WeakMap = window.WeakMap;
    let WeakSet = window.WeakSet;
    let TextDecoder = window.TextDecoder;
    let Uint8Array = window.Uint8Array;
    let decodeURIComponent = window.decodeURIComponent;
    let URLSearchParams = window.URLSearchParams;
    let Array = window.Array;
    let Object = window.Object;
    let atob = window.atob;
    let CustomEvent = window.CustomEvent;
    let performance = window.performance;
    let JSON = window.JSON;

    /*
     * Under some circumstances the iframe isn't added
     * successfully. If it has a contentWindow then we can extract the
     * values from it, but otherwise we fall back on the global
     * values.
     */
    if (iframe.contentWindow) {
        // Try block because sometimes the CORS prevents access to iframe
        try {
            URL = iframe.contentWindow.URL;
            WeakMap = iframe.contentWindow.WeakMap;
            WeakSet = iframe.contentWindow.WeakSet;
            TextDecoder = iframe.contentWindow.TextDecoder;
            Uint8Array = iframe.contentWindow.Uint8Array;
            decodeURIComponent = iframe.contentWindow.decodeURIComponent;
            URLSearchParams = iframe.contentWindow.URLSearchParams;
            Array = iframe.contentWindow.Array;
            Object = iframe.contentWindow.Object;
            atob = iframe.contentWindow.atob;
            CustomEvent = iframe.contentWindow.CustomEvent;
            performance = iframe.contentWindow.performance;
            JSON = iframe.contentWindow.JSON;
        } catch (error) {
            // Empty catch block to prevent errors from showing in page logs
        }
    }

    // If iframe was added successfully, remove it
    if (iframe.parentNode) {
        iframe.parentNode.removeChild(iframe);
    }

    /*
     * If any of the values don't have the correct type, return and
     * don't attempt any monkey patching. This avoids breaking web
     * pages.
     */
    for (f of [
        URL,
        WeakMap,
        WeakSet,
        TextDecoder,
        Uint8Array,
        decodeURIComponent,
        URLSearchParams,
        Array,
        Object,
        atob,
        CustomEvent,
    ]) {
        if (typeof f !== 'function') {
            return;
        }
    }

    for (o of [performance, JSON]) {
        if (typeof o !== 'object') {
            return;
        }
    }

    /*
     * Override common funcions that accept callbacks, such as
     * setInterval, to keep track of what script each callback comes
     * from. Skimmers commonly have the actual skimming code in a
     * callback, so most of the time when we intercept a request,
     * document.currentScript is null. To solve this, the script is
     * stored in a closure when the callback is passed, and assigned
     * to callbackCurrentscript when the callback is run.
     */

    let callbackCurrentScript = null;

    // Maps callbacks originally passed to patched versions
    const patchedCallbackMap = new WeakMap();

    // Maps patched callbacks to original versions
    const originalCallbackMap = new WeakMap();

    /**
     *  Generates the function with which to override the
     *  callback-accepting functions.
     *  @param realFn The real function, e.g. setInterval.
     *  @param callbackIndex The index of the callback in the
     *  arguments of realFn. For example, the callback is the first
     *  argument in setInterval, so callbackIndex should be 0.
     */
    function generateAddCallbackFunction(realFn, callbackIndex) {
        return function(...args) {
            const script = document.currentScript || callbackCurrentScript;

            const callback = args[callbackIndex];

            // If the callback isn't a function, there's nothing to patch
            if (typeof callback !== 'function') {
                return realFn.apply(this, args);
            }

            // If a patch exists, use it instead of creating new function
            let patchedCallback = patchedCallbackMap.get(callback);
            if (!patchedCallback) {
                patchedCallback = function(e) {
                    callbackCurrentScript = script;
                    const retVal = callback.apply(
                        this,
                        e !== undefined ? [e] : []
                    );
                    callbackCurrentScript = null;
                    return retVal;
                };
                patchedCallbackMap.set(callback, patchedCallback);
                originalCallbackMap.set(patchedCallback, callback);
            }

            args[callbackIndex] = patchedCallback;
            return realFn.apply(this, args);
        };
    }

    const realSetInterval = window.setInterval;

    window.setInterval = generateAddCallbackFunction(realSetInterval, 0);

    const realSetTimeout = window.setTimeout;

    window.setTimeout = generateAddCallbackFunction(realSetTimeout, 0);

    const realAddEventListener = EventTarget.prototype.addEventListener;

    EventTarget.prototype.addEventListener = generateAddCallbackFunction(
        realAddEventListener,
        1
    );

    /*
     * removeEventListener needs to be patched to map the passed
     * listener to the patched listener.
     */
    const realRemoveEventListener = EventTarget.prototype.removeEventListener;
    EventTarget.prototype.removeEventListener = function(...args) {
        args[1] = patchedCallbackMap.get(args[1]) || args[1];

        return realRemoveEventListener.apply(this, args);
    };

    /*
     * Event listeners are sometimes set by directly assigning to a
     * property from the GlobalEventHandlers mixin,
     * e.g. 'submitBtn.onclick'. For each of the GlobalEventHandlers
     * implementations that are likely to be relevant, the event
     * properties likely to be used by skimmers are overridden with
     * our version that tracks currentScript when assigned.
     */
    for (const eventTarget of [
        HTMLElement.prototype,
        Document.prototype,
        window,
    ]) {
        for (const eventName of [
            'onclick',
            'onblur',
            'onfocus',
            'onchange',
            'oninput',
            'onkeydown',
            'onkeypress',
            'onkeyup',
            'onload',
            'onloadend',
            'onmousedown',
            'onmouseenter',
            'onmouseleave',
            'onmousemove',
            'onmouseout',
            'onmouseover',
            'onmouseup',
            'onpointerdown',
            'onpointermove',
            'onpointerup',
            'onpointerover',
            'onpointerout',
            'onpointerenter',
            'onpointerleave',
            'onsubmit',
        ]) {
            const descriptor = Object.getOwnPropertyDescriptor(
                eventTarget,
                eventName
            );

            if (!descriptor) {
                continue;
            }

            const realGetter = descriptor.get;
            const realSetter = descriptor.set;

            const patchedSetter = generateAddCallbackFunction(realSetter, 0);

            /*
             * In case a script checks the value of the property after
             * setting it, the getter has to be patched to return the
             * original callback.
             */
            const patchedGetter = function() {
                const realValue = realGetter.call(this);

                const originalCallback = originalCallbackMap.get(realValue);
                if (originalCallback) {
                    return originalCallback;
                } else {
                    return realValue;
                }
            };

            Object.defineProperty(eventTarget, eventName, {
                get: patchedGetter,
                set: patchedSetter,
            });
        }
    }

    /*
     * This script has some dependencies that need to be included
     * without polluting the global namespace. This is achieved by
     * inserting them into the source at build time in the
     * makefile. This is preferable to loading the dependencies via
     * AJAX, because the latter doesn't work if the CSP disallows
     * unsafe-eval. The following tag tells the makefile where to
     * insert the dependencies.
     */
    // <DEPENDENCIES>
class InputAnalyser {
    constructor(_inputs) {
        this._inputs = _inputs;
        this._irrelevantInputs = new WeakSet();

        /*
         * Not currently using Password because it was causing too
         * many false positives. Some sites use external auth domains,
         * and many have misconfigured analytics that collect
         * passwords.
         */
        this.relevantInputs = [new CardNumber()];
    }

    get relevantInputValues() {
        const inputs = {};
        this._inputs.forEach(
            input => (inputs[input.id || input.name] = input.value)
        );

        return inputs;
    }

    get relevantFilledInputs() {
        return this.allInputs
            .filter(input => this.isRelevantElement(input))
            .filter(input => input.value.length >= cons.minInputSize)
            .map(input => ({
                id: input.id,
                name: input.name,
                value: input.value,
            }));
    }

    get allInputs() {
        this._inputs = [
            ...document.querySelectorAll(
                this.relevantInputs.map(i => i.relevantInputTypes).join(', ')
            ),
        ];

        return this._inputs;
    }

    static getLabelText(input) {
        if (!input.labels.length) {
            return '';
        }
        return stripSpecialChars(input.labels[0].textContent).trim();
    }

    /**
     * Takes an HTMLElement and determines whether or not it could be relevant for the purposes of
     * skimmer detection.
     * @param {HTMLElement} input The element which is to be checked for relevancy.
     * @returns {boolean} Returns true if the element is potentially relevant (e.g. a credit card
     * field or other such sensitive input).
     */
    isRelevantElement(input) {
        // If the element has been identified as irrelevant, return false
        if (this._irrelevantInputs.has(input)) {
            return false;
        }

        // Check the input against all the relevant input types
        const relevances = this.relevantInputs.map(i => i.test(input));

        /*
         *  If they all agree that this input is unlikely to become
         *  relevant, exclude it from further checks and return false
         */
        if (relevances.every(i => i === RelevantInput.relevance.NOT_RELEVANT)) {
            this._irrelevantInputs.add(input);
            return false;
        }

        // Return true if any consider the input to be relevant, otherwise false
        return relevances.some(i => i === RelevantInput.relevance.RELEVANT);
    }
}
/*
 * Input Matcher represents a class that can have matches with relevant inputs.
 * Each class that inherits must implement the findInputMatches method.
 */
class InputMatcher {
    /*
     * Finds any matches with the list of inputs.
     * @param inputs. An object whose values represent relevant inputs.
     * @return {[String]} The keys of the inputs that were found.
     */
    findInputMatches(inputs) {
        throw new Error('findInputMatches has not been implemented.');
    }

    /**
     * Determines whether one or more values in needles are present in any of
     * the keys of the haystacks.
     * Checks both raw input and base64 encoded versions of the needles.
     * @param needles An object. The haystacks are searched for the values of
     * this object.
     * @param haystacks The array of strings in which the needle(s) may reside.
     * A string may optionally be supplied if only one value is present.
     * @returns {[String]} The keys of the needles that were found in one or
     * more haystacks in either raw or base64 encoded form.
     */
    static atLeastOneNeedleInHaystack(needles, haystacks) {
        if (
            needles === undefined ||
            needles.length === 0 ||
            haystacks === undefined
        ) {
            return [];
        }

        const searchArray = Array.isArray(haystacks) ? haystacks : [haystacks];

        return Object.entries(needles)
            .filter(([_, needle]) =>
                searchArray.some(haystack => {
                    if (isBase64Encoded(haystack)) {
                        if (atob(haystack).indexOf(needle) !== -1) {
                            return true;
                        }
                    }
                    return haystack.indexOf(needle) !== -1;
                })
            )
            .map(([input, _]) => input);
    }
}
/*
 * Matcher for an object that cannot contain any inputs.
 */
class EmptyMatcher extends InputMatcher {
    findInputMatches(inputs) {
        return [];
    }
}

class URLParamsMatcher extends InputMatcher {
    constructor(url) {
        super();
        this._url = url;
    }

    findInputMatches(inputs) {
        try {
            const parsedUrl = new URL(this._url);
            return InputMatcher.atLeastOneNeedleInHaystack(inputs, [
                ...parsedUrl.searchParams.values(),
            ]);
        } catch (e) {
            return [];
        }
    }
}

class StringBodyMatcher extends InputMatcher {
    constructor(str) {
        super();
        this._str = str;
    }

    findInputMatches(inputs) {
        let decoded;
        try {
            decoded = decodeURIComponent(this._str);
        } catch (e) {
            decoded = this._str;
        }

        const searchParams = new URLSearchParams(decoded);
        const parsedQuery = {};
        const parsedValues = [];

        for (const [key, value] of searchParams.entries()) {
            parsedQuery[key] = value;
            parsedValues.push(value);
        }

        if (parsedQuery !== {} && parsedValues.indexOf(null) === -1) {
            return InputMatcher.atLeastOneNeedleInHaystack(
                inputs,
                parsedValues
            );
        }
        return InputMatcher.atLeastOneNeedleInHaystack(inputs, decoded);
    }
}

class FormBodyMatcher extends InputMatcher {
    constructor(formData) {
        super();
        this._formData = formData;
    }

    findInputMatches(inputs) {
        return InputMatcher.atLeastOneNeedleInHaystack(
            inputs,
            Object.values(this._formData).flat()
        );
    }
}
/**
 * Takes a string and removes a variety of 'special' characters like punctuation.
 * @param str The string to be modified.
 * @returns {string} The resulting string without any special characters.
 */
function stripSpecialChars(str) {
    return str.replace(/[`~!@#$%^&*()_|+\-=?;:'",.<>}{\][\\/]/gi, '');
}

/**
 * Attempts to identify where a string is base-64 encoded or not.
 * @param string The raw string to be examined.
 * @returns {boolean} Returns true if the string matches a base-64 string. False otherwise.
 */
function isBase64Encoded(string) {
    return /^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)?$/.test(
        string
    );
}

// Computes the base64 sha512/sha224 hash of some text, removing trailing ==
function base64hash(hashFunction, text) {
    return btoa(
        hashFunction
            .array(text)
            .map(char => String.fromCharCode(char))
            .join('')
    ).slice(0, -2);
}

function normaliseUrl(str) {
    const link = document.createElement('a');
    link.href = str;
    return link.href;
}

/**
 * Check if two URLs match regardless of any partial encoding.
 *
 * Uses decodeURI which can throw a URIError when url is malformed.
 */
function urlsMatch(first, second) {
    try {
        return decodeURI(first) === decodeURI(second);
    } catch (e) {
        return false;
    }
}

function sendMessage(type, data, tabId, options) {
    if (tabId) {
        chrome.tabs.sendMessage(tabId, { data, type }, options);
    } else {
        chrome.runtime.sendMessage({ data, type });
    }
}
/*
 * Netcraft Extension
 * constants JavaScript
 */

/* eslint sort-keys: 'off' */
/* sort-keys is disabled as the constants are separated by type */

// Aligned values here make for easier reading, so we disable prettier

// prettier-ignore
const cons = (function() {
    const cryptojackersUrl = 'https://www.netcraft.com/apps/help/glossary/#crypto-miners';
    const skimmersUrl = 'https://www.netcraft.com/apps/help/glossary/#credit-card-skimmers';
    const evilResourceCrime = 'attempted to load';

    return {
        fields: [
            'topsites',
            'country',
            'netblock',
            'hoster',
            'firstseen',
            'rank',
            'risk',
            'uses_sslv3',
            'pfs',
            'heartbleed',
            'heartbleed_message',
        ],

        // options that can be toggle in options.js and installed flag

        toggleOptions: [
            'installed',
            'block',
            'xss',
            'suspicious',
            'other-malicious-scripts',
            'credential-leaks',
            'analytics',
            'cryptojackers',
            'skimmers',
        ],

        // domains
        mirror:  'https://mirror2.extension.netcraft.com/',
        toolbar: 'https://mirror.toolbar.netcraft.com/',

        // links and faqs
        blogArchive:      'https://news.netcraft.com/archives/',
        browserApp:       'https://www.netcraft.com/apps/browser/',
        cryptojackersUrl,
        extensionStore:   'https://chrome.google.com/webstore/detail/netcraft-anti-phishing-ex/bmejphbfclcpmpohkggcjeibfilpamia',
        heartbleedUrl:    'https://www.netcraft.com/apps/help/glossary/#heartbleed',
        logBlockedVisit:  'https://toolbar.netcraft.com/blocked_visit',
        netblock:         'https://sitereport.netcraft.com/netblock?q=',
        pfsUrl:           'https://www.netcraft.com/apps/help/glossary/#pfs',
        report:           'https://sitereport.netcraft.com/?url=',
        reportAPI:        'https://report.netcraft.com/api/v2/report/urls',
        reportMistake:    'https://report.netcraft.com/report/mistake?url=',
        skimmersUrl,
        sslv3Url:         'https://www.netcraft.com/apps/help/glossary/#sslv3',
        submissionURL:    'https://report.netcraft.com/submission/',
        topsites:         'https://trends.netcraft.com/topsites?s=',

        // paths
        block:              'blocked.html',
        check:              'check_url/v3/',
        danger:             'Images/danger.png',
        embed:              '/embedded',
        evilJSPatternsFeed: 'eviljspatterns',
        skimmerDomainWhitelistFeed: 'eviljsskimmerwhitelist',
        evilResourcesFeed:  'blockdb/netcraft_extension_evil_resource_encrypted-yppL7bVh/',
        flags:              'Images/flags/',
        force:              '/dodns',
        heartbleed:         'Images/heartbleed.png',
        info:               '/info',
        poodlePost:         '2014/10/15/googles-poodle-affects-oodles.html',
        warning:            'Images/warning.png',

        // feed constants
        evilResourceTypes: ['cryptojacker', 'skimmer'],
        evilResourcesSalt: 'C4jhYHxW',
        maxRevisions:      5,
        randomSaltLength:  8,

        // mappings of url_type => information
        urlTypeInformationMappings: {
            'malware_cryptojacker': ['web miners',             cryptojackersUrl],
            'malware_skimmer':      ['shopping site skimmers', skimmersUrl],
        },

        // mappings of evilResourceTypes => user options
        evilResourceOptionMappings: {
            'cryptojacker': 'cryptojackers',
            'skimmer':      'skimmers'
        },

        // mappings of user options => url_type
        optionUrlTypeMappings: {
            'block':                   /^(phish_site|unavailable)$/,
            'cryptojackers':           /^malware_cryptojacker$/,
            'other-malicious-scripts': /^malware(_(?!(skimmer|cryptojacker)$)\w+)?$/,
            'skimmers':                /^malware_skimmer(_credential_drop)?$/,
        },

        // report constants
        malwareSourceEmail:  'extension-reported-malware@netcraft.com',
        malwareSourceUUID:   'mwcCcApi89cobY9loJ9rWJ9HuOhlpwMj',
        extensionSourceUUID: 'qBEQ3NhEnwK4sypmuSxBJzRqpxZLRXxe',

        // report error default message
        reportErrorMessage: 'An error occured with your submission. Please try again.',

        // mapping from report API errors to displayed messages
        reportErrorMappings: {
            'Duplicate of a recent submission': 'This URL has already been reported.',
            'Supplied email is not valid': 'Invalid email address. Please correct it and try again.',
        },

        whitelistErrorMessages: {
            invalidHostname: 'Invalid hostname, please correct it and try again',
            duplicate: 'Protection is already disabled for this site',
        },

        // browserAction icon paths
        iconNormal: {
            19: 'Images/action-normal.png',
            38: 'Images/action-normal-2x.png'
        },
        iconDanger: {
            19: 'Images/action-danger.png',
            38: 'Images/action-danger-2x.png'
        },
        iconWarning: {
            19: 'Images/action-warning.png',
            38: 'Images/action-warning-2x.png'
        },
        iconDisabled: {
            19: 'Images/action-disabled.png',
            38: 'Images/action-disabled-2x.png'
        },

        // Extension internal message types
        capturedIntercept:  'interceptDetailsCaptured',
        confirmedIntercept: 'interceptDetailsConfirmed',
        contentReady:       'contentScriptReady',
        leaksEnabled:       'credentialLeaksEnabled',
        reportURL:          'report',
        reqBlock:           'block',
        reqDetails:         'details',
        reqForce:           'force',
        reqPopUp:           'popup',
        reqPrintTimingData: 'time', //debug
        reqInputs:          'requestInputValues',
        sendInputs:         'sendInputs',
        sendIntercept:      'sendInterceptDetails',
        updateOption:       'updateOption',
        updateWhitelist:    'whitelist', // disable button whitelist

        // Status codes
        errEvilResource: 'EVILRESOURCE',
        errNoDetails:    'NODETAILS',
        errNoInfo:       'NOINFO',
        errBlocked:      'BLOCKED',
        errPending:      'PENDING',
        errServer:       'ERROR',
        errSuspicious:   'SUSPICIOUS',
        errTimeout:      'TIMEOUT',
        errXSS:          'XSS',
        noError:         'OK',

        // Valid protocols (it is a regex match so ^ matches start of string)
        protocols:    ['^http', '^https', '^ftp'],

        // Human readable messages
        msgNa:           'NA',
        msgNewSite:      'New Site',
        msgNoInfo:       'Site information not available',
        msgNoServer:     'Unable to contact Netcraft servers',
        msgSuspicious:   'Suspicious URL Detected',
        msgXSS:          'Suspected XSS Attack',
        msgBlocked:      {
            'phish_site': {
                title: 'Suspected Phishing',
                description: 'suspected phishing site'
            },
            'malware': {
                title: 'Malicious JavaScript Detected',
                description: 'website containing malicious JavaScript'
            },
            'malware_skimmer': {
                title: 'Shopping Site Skimmer Detected',
                description: 'shopping site skimmer'
            },
            'malware_skimmer_credential_drop': {
                title: 'Potential Credential Leak Detected',
                description: 'potential credential leak'
            },
            'malware_cryptojacker': {
                title: 'Web Miner Detected',
                description: 'web miner'
            },
            'malware_c2': {
                title: 'Malicious URL',
                description: 'malicious page'
            },
            'unavailable': {
                title: 'Suspected Phishing',
                description: 'suspected phishing site'
            },
        },

        // Human readable reasons
        urlTypeCrimeMappings: {
            'malware_skimmer':                 evilResourceCrime,
            'malware_cryptojacker':            evilResourceCrime,
            'malware_undefined':               evilResourceCrime,
            'malware_skimmer_credential_drop': ' is blocked because we detected that sensitive information was leaked from',
        },

        // Timeout function value to clear cache etc.
        timeout:      300000,

        // Skimmer whitelist update interval (1 day)
        skimmerWhitelistInterval: 1000 * 60 * 60 * 24,

        // Google Analytics account
        account:      'UA-2150242-8',
        gaCategory:   'Popup load times',

        // InputAnalyser constants
        minInputSize: 5,

        // First addresses of the private IPv4 netblocks
        privateIPv4Blocks: [
            '10.0.0.0',
            '172.16.0.0',
            '192.168.0.0'
        ],

        // Sync storage key for disable for this site button whitelist
        disableButtonWhitelistKey: 'disableButtonWhitelist',

        // Local storage key for local credential leak detection whitelist
        localCredentialLeakWhitelistKey: 'localCredentialLeakWhitelist',

        // Whitelisted fileName regexes for credential leak detection
        credentialLeakFileNameWhitelist: [
            /^https?:\/\/googleads.g.doubleclick.net\//,
        ],
    };
})();

/*
 * recursively prevents any property or sub-property in cons from:
 *   - being added;
 *   - being removed; or
 *   - being modified.
 */
function deepFreeze(object) {
    Object.freeze(object);

    for (const name of Object.getOwnPropertyNames(object)) {
        if (typeof object[name] === 'object') {
            deepFreeze(object[name]);
        }
    }
}

deepFreeze(cons);
/*
 * RelevantInput objects check whether given form inputs should be
 * treated as sensitive data.
 *
 * This should be treated as an abstract class. Only the subclasses
 * are intended to be instantiated.
 */
class RelevantInput {
    /*
     * Enum of the possible return values of test():
     * RELEVANT:
     *     Input is relevant now, outgoing requests should be
     *     checked for the contained value (subject to minimum length).
     * POTENTIALLY RELEVANT:
     *     Input should not be considered relevant now, but may be in
     *     future so should continue to be checked.
     * NOT_RELEVANT:
     *     Input is not relevant and will not become relevant, so can
     *     be ommitted from further checks to optimise performance.
     */
    static get relevance() {
        return {
            NOT_RELEVANT: 1,
            POTENTIALLY_RELEVANT: 2,
            RELEVANT: 3,
        };
    }

    /*
     * relevantInputTypes (string) - a comma separated list of
     * selectors that describe the types of input that should be
     * considered relevant.
     */
    constructor(relevantInputTypes) {
        this.relevantInputTypes = relevantInputTypes;
    }

    /*
     * Checks whether any of the given input's 'labels' (the ID, name,
     * or actual label) match the given regex.
     */
    static testInputLabel(regex, input) {
        const labels = [
            input.id,
            input.name,
            InputAnalyser.getLabelText(input),
        ];
        return labels.some(label => regex.test(label));
    }
}

/*
 * RelevantInput for passwords.
 */
class Password extends RelevantInput {
    constructor() {
        super('input[type=password]');
    }

    /*
     * Passwords are verified purely by their input type.
     */
    test(input) {
        if (input.matches(this.relevantInputTypes)) {
            return RelevantInput.relevance.RELEVANT;
        } else {
            return RelevantInput.relevance.NOT_RELEVANT;
        }
    }
}

/*
 * RelevantInput for card numbers.
 */
class CardNumber extends RelevantInput {
    constructor() {
        // Inputs with no type attribute act like text inputs
        super(
            'input[type=text], input[type=tel], input[type=number], input:not([type])'
        );

        // Definitely card number labels
        this.inputLabelRegexes = [
            /(cc|card).?(num|no)/i,
            /カード番号/,
            /Номер.*карты/i,
            /信用卡卡號/i,
            /信用卡号码/i,
        ];

        /*
         * Matches incomplete card numbers, because ideally the
         * skimmer should be detected before the victim gives away
         * most of their card number.
         */
        this.inputValueRegexes = [/^(\d{4}[-\s]?){0,4}\d{1,4}$/];

        // Probably card number labels
        this.suspectInputLabelRegexes = [
            /card/i,
            /tarjeta/i,
            /carte/i,
            /карты/i,
            /卡/i,
            /カード/i,
            /카드/i,
            /credit[^s]/i,
        ];

        // If it matches one of these, probably not a card number
        this.inputLabelExceptionRegexes = [
            /post/i,
            /code/i,
            /zip/i,
            /acctn(um|o)/i,
            /loyalty/i,
        ];
    }

    test(input) {
        if (!input.matches(this.relevantInputTypes)) {
            return RelevantInput.relevance.NOT_RELEVANT;
        }

        // Return NOT_RELEVANT if label matches an exception regex
        if (
            this.inputLabelExceptionRegexes.some(r =>
                RelevantInput.testInputLabel(r, input)
            )
        ) {
            return RelevantInput.relevance.NOT_RELEVANT;
        }

        // Return RELEVANT if label clearly states card number
        if (
            this.inputLabelRegexes.some(r =>
                RelevantInput.testInputLabel(r, input)
            )
        ) {
            return RelevantInput.relevance.RELEVANT;
        }

        /*
         * If label suggests card number, return RELEVANT if value
         * also suggests card number or POTENTIALLY_RELEVANT if
         * not. Otherwise, return NOT_RELEVANT as this element will
         * not become relevant unless a label changes (unlikely).
         */
        if (
            this.suspectInputLabelRegexes.some(r =>
                RelevantInput.testInputLabel(r, input)
            )
        ) {
            if (this.inputValueRegexes.some(r => r.test(input.value))) {
                return RelevantInput.relevance.RELEVANT;
            } else {
                return RelevantInput.relevance.POTENTIALLY_RELEVANT;
            }
        } else {
            return RelevantInput.relevance.NOT_RELEVANT;
        }
    }
}

    const inputAnalyser = new InputAnalyser();

    const resourceBlockList = new Set([
                            "0AA024BBE686EA1A3B6FDFDB28863ACC", "0EE2FAB15BD9FC69E943B8BCFD7AFA29", "154B0CD579D48A68ED0292A3F4620038", "168EA45AE35EBF9555BFDC9DF5667629", "1A07F2E29780A416B740F504412C510D", "1CE0C13E7BC1D570296617141A1BA9E8", "1FB784EBAFDA1618023756BF5B6D7E46", "216E8D5C868E3A0030F5742AF986090E", "21CC156F744FCE20418F0A32F4D61AF0", "22DA2498A9670C1EFB46436D1C29A27E", "25A781F6D1F94EEACCF1E00E844D9E14", "2771E421D0F9AA0AAA20FFFA901476A3", "2941ADAD565B3E1D682189B9AF8AB3E4", "2B198ACC86366F5AB6F0FDA993F18826", "455BC4660ADB80ECF59BC27A709559D3", "45EF68CA81C3C2E85EA15B1D46F3C214", "46A7790AF936465507F8E1551A9950C3", "47E46FED2318CC9BB70247B7677E870C", "4FC9BCB4A9C163A0939FF96246F5096A", "598409C45801A54A5E7189287014C844", "59C8CEDAF2D9152C28AF3D3C8E3333A9", "6192AA1BE9EB41D6C7FDECF0C5CBE7CE", "65948A6C490C94647BD206C2EBCE8A34", "6C590F97DDB1A11AE795B3050E4C3866", "73B66880766F9B1C5D2C04B8AD86D67F", "73E6B5C160E25D056DA2BC373ABAF4EC", "76826D272BD6C7544A1012C4FC7044A5", "793D4DABAAA377A12F2B6CE88C5FB389", "7B42B3266838B645CFEF800D8ADB64FB", "7B4AE2743C419CD055DC468204DC59AF", "7CDB2A3A29E50F90C1000252EF523AD6", "81340CAF7E94F887757957D0FE12B290", "82B0832FCAC5D3B770A67D823D11C9FD", "87CC453A8797C9991CFD52378AEFBA4B", "8B09370DF614B196200CB4AC643463E0", "8B11678667DE7AFF0D61DD2921E537E7", "93565242127DD4786FE9C45E40E52A06", "959950F42F1ECD85BDF967B3D0F5A8B8", "9779AF0AF59A15184D2D591E9C269061", "98EB535A06DF1AABF783869666860353", "9AEA2E41B0F571B832CDE26BC0968140", "9E278F7642FD9A41B79CC6DC5FE34783", "A13D0E1BB83AF49BDCF33FB77AF5A468", "AC8A4B13A411A4E43E61D0A034FA4A55", "AD24DD407D411863540505CE356D0A98", "B5232967562E69A7D9C4E75278B9C69C", "BEDF2A87C7E17236ECA1781A7ED47EBD", "C19745453287A75AF0E7FD0A9CD941E6", "C81FC679D0AEBECE449FDA6E42925CCE", "D285BE79786E2ECE396941331C5BA65E", "DC5D63217338D0521DD4C53B5360855B", "DCC3DB001334F29C1C0208D15E9EAB49", "DD958F6595C32F2D03B9240223F7536F", "F0773B746239658328871E8A0EC37BED", "F199CCA250FEB8FC3192E88C19195F63", "F23E9F44AB005AD3CA2A91A7E68566D8", "FE506D9318A1DCC2115D4599DDB5B372", "FEE132122C9FA087E22378E21088D319"
                        ]);
    const evilJSPatterns = new Set([
                            
                        ]);

    // Extract body object
    function extractBody(data) {
        if (!data) {
            return Promise.resolve({});
        }
        if (FormData.prototype.isPrototypeOf(data)) {
            const formData = {};
            for (const [key, value] of data.entries()) {
                formData[key] = value;
            }
            return Promise.resolve({ formData });
        }
        // Create a temporary Request object to parse the body
        const tempRequest = new Request('', { body: data, method: 'POST' });
        return extractBodyFromRequest(tempRequest);
    }

    function extractBodyFromRequest(request) {
        // Try to extract as text
        return request
            .text()
            .then(text => {
                return { text };
            })
            .catch(e => {
                return {};
            });
    }

    /**
     * This function checks if the request hostname/URL is in the blocklist.
     * Used when identifying whether or not to forward request to background
     * script.
     * @param hostname Hostname to check against blocklist.
     * @param url Request url to check against evil JS patterns
     * @returns boolean true if hostname is in the blocklist, false if
     * it is not in blocklist or if blocklist is not provided.
     */
    function requestInBlocklist(hostname, url) {
        if (resourceBlockList === undefined || evilJSPatterns === undefined) {
            return false;
        }
        if (testEvilJS(url.replace(/^(https?:)?\/\//i, ''))) {
            return true;
        }
        while (!testEvilJS(hostname) && !testResource(hostname)) {
            const newHostname = hostname.replace(/^.+?\./g, '');

            if (hostname === newHostname) return false;

            hostname = newHostname;
        }
        return true;
    }

    function testEvilJS(url) {
        return evilJSPatterns.has(base64hash(sha512, url));
    }

    function testResource(hostname) {
        return resourceBlockList.has(
            md5(cons.evilResourcesSalt + hostname).toUpperCase()
        );
    }

    /*
     * Implementations to overwrite window.XMLHttpRequest.prototype.open,
     * window.XMLHttpRequest.prototype.send and window.fetch. These are (to my knowledge) the two
     * APIs that can be used to make requests within Javascript. If there are more, then they will
     * also need to be overridden and intercepted like below.
     */

    /**
     * This function generates functions to be used for wrapping and intercepting network
     * requests, namely from XMLHttpRequest and the Fetch API. It works by taking the real
     * function we want to intercept the request for, and then uses document.currentScript to work
     * out which file initiated the request. It sends those details to the content script which
     * forwards it to the background script, and then we await a confirmation of receipt from the
     * background page. Finally, the real request is sent by forwarding parameters to the original
     * function passed in.
     * @param realFn A reference to the real function that is being intercepted.
     * @param getRequestUrlFn A function used to get the request URL from the object. This is
     * necessary as the mechanisms for different objects differs depending on implementation.
     * @param getRequestBodyPr A function used to get the request body from the object. Returns
     * a promise. It should be null if it's not applicable (e.g. if it sets the src of an image or script).
     * @param type The type of request, which will be a ResourceType:
     * https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/webRequest/ResourceType
     * @returns {function(...[*]=): PromiseLike<any | never>}
     */
    function generateRequestInterceptFn(
        realFn,
        getRequestUrlFn,
        getRequestBodyPr,
        type
    ) {
        return function(...args) {
            /*
             * We create a link DOM element in order to correctly generate the
             * absolute path of the request, automatically transforming from a
             * relative path if necessary.
             */
            const requestUrl = normaliseUrl(
                getRequestUrlFn.bind(this)(...args)
            );

            let requestHostname;
            let pageHostname;

            try {
                requestHostname = new URL(requestUrl).hostname;
                pageHostname = new URL(location.href).hostname;
            } catch (e) {
                return realFn.apply(this, args);
            }

            /*
             * If hostname is in the blocklist, the request should always be
             * sent to the background script.
             */
            // eslint-disable-next-line prefer-const
            let forceStall = false;

            if (!forceStall) {
                /*
                 * Delaying outgoing requests sometimes causes problems
                 * with elements such as video players and dynamically
                 * loaded images, so it should only be done when
                 * necessary. Before inputAnalyser is defined and when the
                 * request is to the same hostname as the page, this can
                 * be skipped.
                 */
                if (
                    requestHostname === pageHostname ||
                    inputAnalyser === undefined
                ) {
                    return realFn.apply(this, args);
                }

                /*
                 * It can also be skipped if there is no sensitive
                 * information entered into a form on the page yet.
                 */
                const relevantFilledInputs = inputAnalyser.relevantFilledInputs;
                if (!relevantFilledInputs.length) {
                    return realFn.apply(this, args);
                }

                /*
                 * For requests with no body, it's only necessary to delay
                 * them when the sensitive information from the form
                 * inputs is present in the request URL.
                 */
                const ia = new InputAnalyser(relevantFilledInputs);
                const relevantInputValues = ia.relevantInputValues;
                const urlMatcher = new URLParamsMatcher(requestUrl);

                if (
                    getRequestBodyPr === null &&
                    !urlMatcher.findInputMatches(relevantInputValues).length
                ) {
                    return realFn.apply(this, args);
                }
            }

            /*
             * Create a promise that resolves immediately if the request body
             * does not apply to this request.
             */
            if (getRequestBodyPr === null) {
                getRequestBodyPr = function() {
                    return Promise.resolve({});
                };
            }

            return getRequestBodyPr
                .bind(this)(...args)
                .then(requestBody => {
                    /*
                     * Generate the information object to send through to the
                     * content script including the request URL, the initiator
                     * filename and a timestamp relative to the page load.
                     */
                    let fileName;
                    if (document.currentScript) {
                        fileName = document.currentScript.src;
                    } else if (
                        callbackCurrentScript &&
                        callbackCurrentScript.src
                    ) {
                        fileName = callbackCurrentScript.src;
                    } else {
                        fileName = location.href;
                    }

                    const detail = {
                        fileName,
                        requestBody,
                        requestUrl,
                        timestamp: performance.now(),
                        type,
                    };

                    document.dispatchEvent(
                        new CustomEvent(cons.capturedIntercept, {
                            detail,
                        })
                    );

                    return new Promise(resolve => {
                        /*
                         * Send the initiator's file name and other info to the
                         * background script, then wait for confirmation that the
                         * details made it to the background page before calling
                         * the real function. This is to avoid any race conditions
                         * whereby the details haven't been added to the tab data
                         * before onBeforeRequest/onBeforeSendHeaders gets called.
                         */
                        document.addEventListener(
                            cons.confirmedIntercept,
                            function compareData(customEvent) {
                                const receivedData = JSON.parse(
                                    customEvent.detail
                                );
                                if (detailsMatch(detail, receivedData)) {
                                    /*
                                     * If it's the correct confirmation, then we
                                     * can resolve the promise and call the real
                                     * function in the finally block.
                                     */
                                    document.removeEventListener(
                                        cons.confirmedIntercept,
                                        compareData,
                                        false
                                    );
                                    resolve();
                                }
                            }
                        );
                    }).then(() => realFn.apply(this, args));
                });
        };
    }

    function detailsMatch(first, second) {
        const comparisonKeys = ['fileName', 'requestUrl', 'timestamp', 'type'];
        for (const key of comparisonKeys) {
            if (first[key] !== second[key]) {
                return false;
            }
        }
        return true;
    }

    window.fetch = generateRequestInterceptFn(
        realFetch,
        request => (typeof request === 'string' ? request : request.url),
        (request, options) => {
            // Check if argument is a Request object.
            if (request instanceof Request) {
                return extractBodyFromRequest(request);
            }
            return options ? extractBody(options.body) : Promise.resolve({});
        },
        'xmlhttprequest'
    );

    window.XMLHttpRequest.prototype.send = generateRequestInterceptFn(
        realSend,
        function getRequestUrl() {
            return this._requestUrl;
        },
        extractBody,
        'xmlhttprequest'
    );

    /*
     * This function is intercepted so that we can capture the value of the
     * request URL, since it isn't present in the arguments for
     * XMLHttpRequest.send (above).
     */
    window.XMLHttpRequest.prototype.open = function open(...args) {
        [, this._requestUrl] = args;
        realOpen.apply(this, args);
    };

    /*
     * Monkeypatches for setting the src of images and scripts, an
     * indirect way of sending requests that is often employed by
     * skimmers. The getters are also overridden to make the behaviour
     * seem identical to the original implementation. Otherwise, if a
     * script were to set an src and immediately read it, it would
     * come back as the old value.
     */

    /*
     * WeakMap maps an object to a value. This is used to store the
     * new src of an object when its true src property may not yet
     * have been set.
     */
    const srcMap = new WeakMap();
    const requestElements = [
        {
            srcElement: HTMLImageElement.prototype,
            type: 'image',
        },
        {
            srcElement: HTMLScriptElement.prototype,
            type: 'script',
        },
    ];

    for (const { srcElement, type } of requestElements) {
        const realGetSrc = Object.getOwnPropertyDescriptor(srcElement, 'src')
            .get;
        const realSetSrc = Object.getOwnPropertyDescriptor(srcElement, 'src')
            .set;
        const realGetAttribute = srcElement.getAttribute;
        const realSetAttribute = srcElement.setAttribute;
        const realRemoveAttribute = srcElement.removeAttribute;

        const interceptFn = generateRequestInterceptFn(
            realSetSrc,
            src => src,
            null,
            type
        );

        function setSrc(url) {
            srcMap.set(this, url);
            interceptFn.call(this, url);
            return url;
        }

        Object.defineProperty(srcElement, 'src', {
            get() {
                if (srcMap.get(this) === undefined) {
                    return realGetSrc.call(this);
                } else {
                    return normaliseUrl(srcMap.get(this));
                }
            },

            set: setSrc,
        });

        srcElement.setAttribute = function(attributeName, value) {
            if (attributeName.toUpperCase() === 'SRC') {
                setSrc.call(this, value);
            } else {
                realSetAttribute.call(this, attributeName, value);
            }
        };

        srcElement.getAttribute = function(attributeName) {
            if (
                attributeName.toUpperCase() === 'SRC' &&
                srcMap.get(this) !== undefined
            ) {
                return srcMap.get(this);
            } else {
                return realGetAttribute.call(this, attributeName);
            }
        };

        srcElement.removeAttribute = function(attributeName) {
            if (attributeName.toUpperCase() === 'SRC') {
                srcMap.delete(this);
            }

            return realRemoveAttribute.call(this, attributeName);
        };
    }
})(
    window.XMLHttpRequest.prototype.open,
    window.XMLHttpRequest.prototype.send,
    window.fetch
);
</script><script nonce="">ServerJSQueue.add(function(){requireLazy(["HasteSupportData"],function(m){m.handle({"clpData":{"1838142":{"r":1,"s":1}},"gkxData":{"185":{"result":true,"hash":"AT5MqNOYoEUII06PMAs"},"708253":{"result":false,"hash":"AT5n4hBL3YTMnQWtSNg"},"1224637":{"result":false,"hash":"AT7JRluWxuwDm3XznA0"},"676837":{"result":false,"hash":"AT4N8wBZA8ctCdHw8aw"},"996940":{"result":false,"hash":"AT7opYuEGy3sjG1aZIs"},"1263340":{"result":false,"hash":"AT5bwizWgDaFQudmP9U"},"1167394":{"result":false,"hash":"AT7BpN-tlUPwbIIFHV4"}}})});});ServerJSQueue.add({"require":[["markJSEnabled"],["lowerDomain"]]});</script><script nonce="">(function(){var a=document.createElement("div");a.innerHTML="<svg/>";if(a.firstChild&&a.firstChild.namespaceURI==="http://www.w3.org/2000/svg"){a=document.documentElement;a.className=a.className.replace("no_svg","svg")}})();</script></head><body dir="ltr" class="plugin chrome webkit win x1 Locale_en_GB" data-new-gr-c-s-loaded="14.1012.0"><div class="_li"><span></span></div><script nonce="">function envFlush(a){function b(b){for(var c in a)b[c]=a[c]}window.requireLazy?window.requireLazy(["Env"],b):(window.Env=window.Env||{},b(window.Env))}envFlush({"ajaxpipe_token":"AXg5CIZskgTL_mbNKJU"});</script><script nonce="">ServerJSQueue.add(function(){requireLazy(["Bootloader"],function(b){b.enableBootload({"ODS":{"r":[],"be":1},"TransportSelectingClientSingleton":{"r":[],"rds":{"m":["ContextualConfig","BladeRunnerClient","DGWRequestStreamClient","MqttLongPollingRunner","BanzaiScuba_DEPRECATED"],"r":[]},"be":1},"RequestStreamCommonRequestStreamCommonTypes":{"r":[],"be":1}})});});</script><script>ServerJSQueue.add({"define":[["CurrentEnvironment",[],{"facebookdotcom":true,"messengerdotcom":false,"workplacedotcom":false},827],["PlatformVersions",[],{"LATEST":"v10.0","versions":{"UNVERSIONED":"unversioned","V1_0":"v1.0","V2_0":"v2.0","V2_1":"v2.1","V2_2":"v2.2","V2_3":"v2.3","V2_4":"v2.4","V2_5":"v2.5","V2_6":"v2.6","V2_7":"v2.7","V2_8":"v2.8","V2_9":"v2.9","V2_10":"v2.10","V2_11":"v2.11","V2_12":"v2.12","V3_0":"v3.0","V3_1":"v3.1","V3_2":"v3.2","V3_3":"v3.3","V4_0":"v4.0","V5_0":"v5.0","V6_0":"v6.0","V7_0":"v7.0","V8_0":"v8.0","V9_0":"v9.0","V10_0":"v10.0"}},1254],["UriNeedRawQuerySVConfig",[],{"uris":["dms.netmng.com","doubleclick.net","r.msn.com","watchit.sky.com","graphite.instagram.com","www.kfc.co.th","learn.pantheon.io","www.landmarkshops.in","www.ncl.com","s0.wp.com","www.tatacliq.com","bs.serving-sys.com","kohls.com","lazada.co.th","xg4ken.com","technopark.ru","officedepot.com.mx","bestbuy.com.mx","booking.com"]},3871],["CometAltpayJsSdkIframeAllowedDomains",[],{"allowed_domains":["https:\/\/live.adyen.com","https:\/\/integration-facebook.payu.in","https:\/\/facebook.payulatam.com","https:\/\/secure.payu.com","https:\/\/facebook.dlocal.com","https:\/\/buy2.boku.com"]},4920],["BootloaderConfig",[],{"deferBootloads":false,"jsRetries":[200,500],"jsRetryAbortNum":2,"jsRetryAbortTime":5,"silentDups":false,"hypStep4":false},329],["CSSLoaderConfig",[],{"timeout":5000,"modulePrefix":"BLCSS:","loadEventSupported":true},619],["CookieCoreConfig",[],{"a11y":{"s":"None"},"c_user":{"s":"None"},"cppo":{"t":86400,"s":"None"},"dpr":{"t":604800,"s":"None"},"fbl_ci":{"t":31536000,"s":"None"},"fbl_cs":{"t":31536000,"s":"None"},"fbl_st":{"t":31536000,"s":"Strict"},"i_user":{"s":"None"},"js_ver":{"t":604800,"s":"None"},"locale":{"t":604800,"s":"None"},"m_pixel_ratio":{"t":604800,"s":"None"},"noscript":{"s":"None"},"presence":{"t":2592000,"s":"None"},"sfau":{"s":"None"},"usida":{"s":"None"},"vpd":{"t":5184000,"s":"Lax"},"wd":{"t":604800,"s":"Lax"},"x-referer":{"s":"None"},"x-src":{"t":1,"s":"None"}},2104],["CurrentCommunityInitialData",[],{},490],["DTSGInitialData",[],{"token":"AQHL-E15wdJJT-A:AQEoZ_bjGuLvqv4"},258],["ISB",[],{},330],["LSD",[],{"token":"Pa95ZqZ-0JI10lJfJrNhjI"},323],["ServerNonce",[],{"ServerNonce":"Gw37G718bpvHOoEJtiXrlj"},141],["SiteData",[],{"server_revision":1003868084,"client_revision":1003868084,"tier":"","push_phase":"C3","pkg_cohort":"PHASED:plugin_default_pkg","haste_session":"18774.PHASED:plugin_default_pkg.2.0.0.0","pr":1,"haste_site":"www","be_one_ahead":false,"ir_on":true,"is_rtl":false,"is_comet":false,"is_experimental_tier":false,"is_jit_warmed_up":true,"hsi":"6966917831754672606","semr_host_bucket":"6","bl_hash_version":2,"skip_rd_bl":true,"spin":0,"__spin_r":1003868084,"__spin_b":"trunk","__spin_t":1622111963,"vip":"157.240.7.35"},317],["SprinkleConfig",[],{"param_name":"jazoest","version":2,"should_randomize":false},2111],["PromiseUsePolyfillSetImmediateGK",[],{"www_always_use_polyfill_setimmediate":false},2190],["KSConfig",[],{"killed":{"__set":["MLHUB_FLOW_AUTOREFRESH_SEARCH","NEKO_DISABLE_CREATE_FOR_SAP","EO_DISABLE_SYSTEM_SERIAL_NUMBER_FREE_TYPING_IN_CPE_NON_CLIENT","EO_SRT_HELPDESK_DASHBOARD_DISABLE_UNUSED_TAB_IN_RIGHT_PANEL","MOBILITY_KILL_OLD_VISIBILITY_POSITION_SETTING","WORKPLACE_DISPLAY_TEXT_EVIDENCE_REPORTING","BUSINESS_INVITE_FLOW_WITH_SELLER_PROFILE","ADS_TEMPLATE_UNIFICATION_IN_IG_STORIES","DCP_CYCLE_COUNT_CLASSIFICATION_UI","BUY_AT_NEW_START_REQUEST_DSUL_BANNER","BUY_AT_UI_LINE_DELETE","BUSINESS_GRAPH_SETTING_APP_ASSIGNED_USERS_NEW_API","BUSINESS_GRAPH_SETTING_BU_ASSIGNED_USERS_NEW_API","BUSINESS_GRAPH_SETTING_ESG_ASSIGNED_USERS_NEW_API","BUSINESS_GRAPH_SETTING_PRODUCT_CATALOG_ASSIGNED_USERS_NEW_API","BUSINESS_GRAPH_SETTING_SESG_ASSIGNED_USERS_NEW_API","BUSINESS_GRAPH_SETTING_WABA_ASSIGNED_USERS_NEW_API","ADS_PLACEMENT_FIX_PUBLISHER_PLATFORMS_MUTATION","FORCE_FETCH_BOOSTED_COMPONENT_AFTER_ADS_CREATION","VIDEO_DIMENSIONS_FROM_PLAYER_IN_UPLOAD_DIALOG","SNIVY_GROUP_BY_EVENT_TRACE_ID_AND_NAME","ADS_STORE_VISITS_METRICS_DEPRECATION","DYNAMIC_ADS_SET_CATALOG_AND_PRODUCT_SET_TOGETHER","AD_DRAFT_ENABLE_SYNCRHONOUS_FRAGMENT_VALIDATION","NEKO_ENABLE_RESET_SAP_FOR_CREATE_AD_SET_CONTEXTUAL","LAB_NET_NEW_UI_RELEASE","HELPDESK_USE_XDS_SEARCHABLE_INPUT_FOR_WORKFLOW","POCKET_MONSTERS_CREATE","POCKET_MONSTERS_DELETE","SRT_BANZAI_SRT_CORE_LOGGER","SRT_BANZAI_SRT_MAIN_LOGGER","SIMPL_SAMPLING_HEALTH_CARD","WORKPLACE_PLATFORM_SECURE_APPS_MAILBOXES","POCKET_MONSTERS_UPDATE_NAME","ADS_INTEGRATION_PORTAL_RELAY_LIVE"]},"ko":{"__set":["3OsLvnSHNTt","1G7wJ6bJt9K","9NpkGYwzrPG","6fHw06UmAMW","3oh5Mw86USj","8NAceEy9JZo","7FOIzos6XJX","6xuJHOrdskA","75fREERrb3F","80ZDn9dpjEA","rf8JEPGgOi","4j36SVzvP3w","4NSq3ZC4ScE","53gCxKq281G","3yzzwBY7Npj","1onzIv0jH6H","8PlKuowafe8","1ntjZ2zgf03","4SIH2GRVX5W","2dhqRnqXGLQ","2WgiNOrHVuC","amKHb4Cw4WI","5mNEXob0nTj","8rDvN9vWdAK","9cL5o2kjfZo","DDZhogI19W","aDayprn6pbH","acrJTh9WGdp","1oOE64fL4wO","9Gd8qgRxn8z","MPMaqnqZ9c","4MzX0ipjWq","5XCz1h9Iaw3","7r6mSP7ofr2","5zgf0XOYSz7"]}},2580],["JSErrorLoggingConfig",[],{"appId":256281040558,"extra":[],"reportInterval":50,"sampleWeight":null,"sampleWeightKey":"__jssesw"},2776],["CookieCoreLoggingConfig",[],{"maximumIgnorableStallMs":16.67,"sampleRate":9.7e-5,"sampleRateClassic":1.0e-10,"sampleRateFastStale":1.0e-8},3401],["ImmediateImplementationExperiments",[],{"prefer_message_channel":true},3419],["DTSGInitData",[],{"token":"AQHL-E15wdJJT-A:AQEoZ_bjGuLvqv4","async_get_token":"AQw0RMAif4_ior85Tyti5M9w23KE1vbVhpdD2FnHJSOWuWRN:AQwhXY5vszb7z6o0qYk0O91ccZ7ErsNNRcexG-24tsz6FK7A"},3515],["InitialCookieConsent",[],{"deferCookies":false,"initialConsent":{"__set":[1,2]},"noCookies":false,"shouldShowCookieBanner":false},4328],["TrustedTypesConfig",[],{"useTrustedTypes":false,"reportOnly":false},4548],["WebConnectionClassServerGuess",[],{"connectionClass":"EXCELLENT"},4705],["BootloaderEndpointConfig",[],{"debugNoBatching":false,"endpointURI":"https:\/\/www.facebook.com\/ajax\/bootloader-endpoint\/"},5094],["TrackingConfig",[],{"domain":"https:\/\/pixel.facebook.com"},325],["ZeroRewriteRules",[],{"rewrite_rules":{},"whitelist":{"\/hr\/r":1,"\/hr\/p":1,"\/zero\/unsupported_browser\/":1,"\/zero\/policy\/optin":1,"\/zero\/optin\/write\/":1,"\/zero\/optin\/legal\/":1,"\/zero\/optin\/free\/":1,"\/about\/privacy\/":1,"\/about\/privacy\/update\/":1,"\/about\/privacy\/update":1,"\/zero\/toggle\/welcome\/":1,"\/zero\/toggle\/nux\/":1,"\/zero\/toggle\/settings\/":1,"\/fup\/interstitial\/":1,"\/work\/landing":1,"\/work\/login\/":1,"\/work\/email\/":1,"\/ai.php":1,"\/js_dialog_resources\/dialog_descriptions_android.json":0,"\/connect\/jsdialog\/MPlatformAppInvitesJSDialog\/":0,"\/connect\/jsdialog\/MPlatformOAuthShimJSDialog\/":0,"\/connect\/jsdialog\/MPlatformLikeJSDialog\/":0,"\/qp\/interstitial\/":1,"\/qp\/action\/redirect\/":1,"\/qp\/action\/close\/":1,"\/zero\/support\/ineligible\/":1,"\/zero_balance_redirect\/":1,"\/zero_balance_redirect":1,"\/zero_balance_redirect\/l\/":1,"\/l.php":1,"\/lsr.php":1,"\/ajax\/dtsg\/":1,"\/checkpoint\/block\/":1,"\/exitdsite":1,"\/zero\/balance\/pixel\/":1,"\/zero\/balance\/":1,"\/zero\/balance\/carrier_landing\/":1,"\/zero\/flex\/logging\/":1,"\/tr":1,"\/tr\/":1,"\/sem_campaigns\/sem_pixel_test\/":1,"\/bookmarks\/flyout\/body\/":1,"\/zero\/subno\/":1,"\/confirmemail.php":1,"\/policies\/":1,"\/mobile\/internetdotorg\/classifier\/":1,"\/zero\/dogfooding":1,"\/xti.php":1,"\/zero\/fblite\/config\/":1,"\/hr\/zsh\/wc\/":1,"\/ajax\/bootloader-endpoint\/":1,"\/mobile\/zero\/carrier_page\/":1,"\/mobile\/zero\/carrier_page\/education_page\/":1,"\/mobile\/zero\/carrier_page\/feature_switch\/":1,"\/mobile\/zero\/carrier_page\/settings_page\/":1,"\/aloha_check_build":1,"\/upsell\/zbd\/softnudge\/":1,"\/4oh4.php":1,"\/autologin.php":1,"\/birthday_help.php":1,"\/checkpoint\/":1,"\/contact-importer\/":1,"\/cr.php":1,"\/legal\/terms\/":1,"\/login.php":1,"\/login\/":1,"\/mobile\/account\/":1,"\/n\/":1,"\/remote_test_device\/":1,"\/upsell\/buy\/":1,"\/upsell\/buyconfirm\/":1,"\/upsell\/buyresult\/":1,"\/upsell\/promos\/":1,"\/upsell\/continue\/":1,"\/upsell\/h\/promos\/":1,"\/upsell\/loan\/learnmore\/":1,"\/upsell\/purchase\/":1,"\/upsell\/promos\/upgrade\/":1,"\/upsell\/buy_redirect\/":1,"\/upsell\/loan\/buyconfirm\/":1,"\/upsell\/loan\/buy\/":1,"\/upsell\/sms\/":1,"\/wap\/a\/channel\/reconnect.php":1,"\/wap\/a\/nux\/wizard\/nav.php":1,"\/wap\/appreg.php":1,"\/wap\/birthday_help.php":1,"\/wap\/c.php":1,"\/wap\/confirmemail.php":1,"\/wap\/cr.php":1,"\/wap\/login.php":1,"\/wap\/r.php":1,"\/zero\/datapolicy":1,"\/a\/timezone.php":1,"\/a\/bz":1,"\/bz\/reliability":1,"\/r.php":1,"\/mr\/":1,"\/reg\/":1,"\/registration\/log\/":1,"\/terms\/":1,"\/f123\/":1,"\/expert\/":1,"\/experts\/":1,"\/terms\/index.php":1,"\/terms.php":1,"\/srr\/":1,"\/msite\/redirect\/":1,"\/fbs\/pixel\/":1,"\/contactpoint\/preconfirmation\/":1,"\/contactpoint\/cliff\/":1,"\/contactpoint\/confirm\/submit\/":1,"\/contactpoint\/confirmed\/":1,"\/contactpoint\/login\/":1,"\/preconfirmation\/contactpoint_change\/":1,"\/help\/contact\/":1,"\/survey\/":1,"\/upsell\/loyaltytopup\/accept\/":1,"\/settings\/":1,"\/lite\/":1,"\/zero_status_update\/":1,"\/operator_store\/":1,"\/upsell\/":1,"\/wifiauth\/login\/":1}},1478],["ServerTimeData",[],{"serverTime":1622111963158,"timeOfRequestStart":1622111963122.8,"timeOfResponseStart":1622111963122.8},5943],["CurrentUserInitialData",[],{"ACCOUNT_ID":"100044570809347","USER_ID":"100044570809347","NAME":"Kai Collin","SHORT_NAME":"Kai","IS_BUSINESS_PERSON_ACCOUNT":false,"HAS_SECONDARY_BUSINESS_PERSON":false,"IS_MESSENGER_ONLY_USER":false,"IS_DEACTIVATED_ALLOWED_ON_MESSENGER":false,"IS_MESSENGER_CALL_GUEST_USER":false,"IS_WORK_MESSENGER_CALL_GUEST_USER":false,"APP_ID":"256281040558","IS_BUSINESS_DOMAIN":false},270],["AnalyticsCoreData",[],{"device_id":"$^|AcaboHyDUPWuo6aquWaA5AeU2mzn8znZ7uBRQJ4A75NwBFno9RuIRaumrS0f_91X9LSOapB7zPiUm4UcwAA9g5uiPi3gREQ2IQ|fd.AcZ_skOyURxB9gFbRWUa0W8xWhdwELsOgLK5EtMBnaS2Oalkgjl1uizVSqBD_CzdZQVAa7EuLXZhgcP119yu56_Z","app_id":"256281040558","enable_bladerunner":true,"enable_ack":true,"push_phase":"C3","enable_observer":false},5237],["cr:696703",[],{"__rc":[null,"Aa39_dtmippeOCODYD2pDN012Jh6KHUgiMSmKYAGjnsEgg53H3sNmSvRqnc6lQuPmjpYDQH-V2zxiAZC5I1QTzzzNIk"]},-1],["cr:717822",["TimeSliceImpl"],{"__rc":["TimeSliceImpl","Aa39_dtmippeOCODYD2pDN012Jh6KHUgiMSmKYAGjnsEgg53H3sNmSvRqnc6lQuPmjpYDQH-V2zxiAZC5I1QTzzzNIk"]},-1],["cr:806696",["clearTimeoutBlue"],{"__rc":["clearTimeoutBlue","Aa39_dtmippeOCODYD2pDN012Jh6KHUgiMSmKYAGjnsEgg53H3sNmSvRqnc6lQuPmjpYDQH-V2zxiAZC5I1QTzzzNIk"]},-1],["cr:807042",["setTimeoutBlue"],{"__rc":["setTimeoutBlue","Aa39_dtmippeOCODYD2pDN012Jh6KHUgiMSmKYAGjnsEgg53H3sNmSvRqnc6lQuPmjpYDQH-V2zxiAZC5I1QTzzzNIk"]},-1],["cr:896462",["setIntervalAcrossTransitionsBlue"],{"__rc":["setIntervalAcrossTransitionsBlue","Aa39_dtmippeOCODYD2pDN012Jh6KHUgiMSmKYAGjnsEgg53H3sNmSvRqnc6lQuPmjpYDQH-V2zxiAZC5I1QTzzzNIk"]},-1],["cr:925100",["RunBlue"],{"__rc":["RunBlue","Aa39_dtmippeOCODYD2pDN012Jh6KHUgiMSmKYAGjnsEgg53H3sNmSvRqnc6lQuPmjpYDQH-V2zxiAZC5I1QTzzzNIk"]},-1],["cr:986633",["setTimeoutAcrossTransitionsBlue"],{"__rc":["setTimeoutAcrossTransitionsBlue","Aa39_dtmippeOCODYD2pDN012Jh6KHUgiMSmKYAGjnsEgg53H3sNmSvRqnc6lQuPmjpYDQH-V2zxiAZC5I1QTzzzNIk"]},-1],["cr:1003267",["clearIntervalBlue"],{"__rc":["clearIntervalBlue","Aa39_dtmippeOCODYD2pDN012Jh6KHUgiMSmKYAGjnsEgg53H3sNmSvRqnc6lQuPmjpYDQH-V2zxiAZC5I1QTzzzNIk"]},-1],["cr:1642797",["BanzaiBase"],{"__rc":["BanzaiBase","Aa39_dtmippeOCODYD2pDN012Jh6KHUgiMSmKYAGjnsEgg53H3sNmSvRqnc6lQuPmjpYDQH-V2zxiAZC5I1QTzzzNIk"]},-1],["BanzaiConfig",[],{"MAX_SIZE":10000,"MAX_WAIT":150000,"MIN_WAIT":null,"RESTORE_WAIT":150000,"blacklist":["time_spent"],"disabled":false,"gks":{"boosted_pagelikes":true,"mercury_send_error_logging":true,"platform_oauth_client_events":true,"visibility_tracking":true,"graphexplorer":true,"sticker_search_ranking":true,"actually_flush_lazy_queue":true},"known_routes":["unified_logging","artillery_javascript_actions","artillery_javascript_trace","artillery_logger_data","logger","falco","gk2_exposure","js_error_logging","loom_trace","marauder","perfx_custom_logger_endpoint","qex","require_cond_exposure_logging","srt_job_view_heartbeats","sri_logger_data"],"should_drop_unknown_routes":true,"should_log_unknown_routes":false},7],["UserAgentData",[],{"browserArchitecture":"64","browserFullVersion":"90.0.4430.212","browserMinorVersion":0,"browserName":"Chrome","browserVersion":90,"deviceName":"Unknown","engineName":"WebKit","engineVersion":"537.36","platformArchitecture":"64","platformName":"Windows","platformVersion":"10","platformFullVersion":"10"},527],["cr:692209",["cancelIdleCallbackBlue"],{"__rc":["cancelIdleCallbackBlue","Aa39_dtmippeOCODYD2pDN012Jh6KHUgiMSmKYAGjnsEgg53H3sNmSvRqnc6lQuPmjpYDQH-V2zxiAZC5I1QTzzzNIk"]},-1]],"require":[["PluginReturn","syncPlugins",[],[]],["WebPixelRatioDetector","startDetecting",[],[false]],["AsyncSignal"],["NavigationMetrics","setPage",[],[{"page":"\/plugins\/page.php","page_type":"widget","page_uri":"https:\/\/www.facebook.com\/plugins\/page.php?href=https\u00253A\u00252F\u00252Fwww.facebook.com\u00252FJbtdrc-287642701902801&tabs=timeline&width=300&height=500&small_header=false&adapt_container_width=true&hide_cover=false&show_facepile=true&appId","serverLID":"6966917831754672606"}]],["FalcoLoggerTransports","attach",[],[]],["BanzaiScuba_DEPRECATED"],["RequireDeferredReference","unblock",[],[["BanzaiScuba_DEPRECATED"]]]]});</script></body></html>